% Options for packages loaded elsewhere
\PassOptionsToPackage{unicode}{hyperref}
\PassOptionsToPackage{hyphens}{url}
%
\documentclass[
]{article}
\usepackage{amsmath,amssymb}
\usepackage{lmodern}
\usepackage{ifxetex,ifluatex}
\ifnum 0\ifxetex 1\fi\ifluatex 1\fi=0 % if pdftex
  \usepackage[T1]{fontenc}
  \usepackage[utf8]{inputenc}
  \usepackage{textcomp} % provide euro and other symbols
\else % if luatex or xetex
  \usepackage{unicode-math}
  \defaultfontfeatures{Scale=MatchLowercase}
  \defaultfontfeatures[\rmfamily]{Ligatures=TeX,Scale=1}
\fi
% Use upquote if available, for straight quotes in verbatim environments
\IfFileExists{upquote.sty}{\usepackage{upquote}}{}
\IfFileExists{microtype.sty}{% use microtype if available
  \usepackage[]{microtype}
  \UseMicrotypeSet[protrusion]{basicmath} % disable protrusion for tt fonts
}{}
\makeatletter
\@ifundefined{KOMAClassName}{% if non-KOMA class
  \IfFileExists{parskip.sty}{%
    \usepackage{parskip}
  }{% else
    \setlength{\parindent}{0pt}
    \setlength{\parskip}{6pt plus 2pt minus 1pt}}
}{% if KOMA class
  \KOMAoptions{parskip=half}}
\makeatother
\usepackage{xcolor}
\IfFileExists{xurl.sty}{\usepackage{xurl}}{} % add URL line breaks if available
\IfFileExists{bookmark.sty}{\usepackage{bookmark}}{\usepackage{hyperref}}
\hypersetup{
  pdftitle={Martingale Strategy Computer Simulation},
  pdfauthor={Zhengqi(Peter) Tian},
  hidelinks,
  pdfcreator={LaTeX via pandoc}}
\urlstyle{same} % disable monospaced font for URLs
\usepackage[margin=1in]{geometry}
\usepackage{graphicx}
\makeatletter
\def\maxwidth{\ifdim\Gin@nat@width>\linewidth\linewidth\else\Gin@nat@width\fi}
\def\maxheight{\ifdim\Gin@nat@height>\textheight\textheight\else\Gin@nat@height\fi}
\makeatother
% Scale images if necessary, so that they will not overflow the page
% margins by default, and it is still possible to overwrite the defaults
% using explicit options in \includegraphics[width, height, ...]{}
\setkeys{Gin}{width=\maxwidth,height=\maxheight,keepaspectratio}
% Set default figure placement to htbp
\makeatletter
\def\fps@figure{htbp}
\makeatother
\setlength{\emergencystretch}{3em} % prevent overfull lines
\providecommand{\tightlist}{%
  \setlength{\itemsep}{0pt}\setlength{\parskip}{0pt}}
\setcounter{secnumdepth}{-\maxdimen} % remove section numbering
\ifluatex
  \usepackage{selnolig}  % disable illegal ligatures
\fi

\title{Martingale Strategy Computer Simulation}
\author{Zhengqi(Peter) Tian}
\date{9/1/2021}

\begin{document}
\maketitle

Reference:
\url{https://github.com/thomasgstewart/data-science-5620-Fall-2021/blob/master/deliverables/01-roulette.md}

\textbf{\emph{Background and Operating Characters}}

 As the purpose of the article, We try to use data science tech to
analyze a class roulette strategy, Martingale strategy. As we known that
a roulette table composed of 38 (or 37) evenly sized pockets on a wheel,
including red, black, or green pockets. The payout for a bet on black is
1 dollar for each wagered. Generally, for each sub sequence, no matter
how many losses happened before the final red win, the win wager will
not only offset the previous lost, but also will earn 1 dollar. To know
whether it will work, as a data scientist,applying computer simulation
will help us understand the scenario.

 To explain how the computer does simulation, first of all, we need
think over key features in the whole procedure by understating the
operating characteristics in the strategy. Generally, there are two
processes, the single spin of the wheel and martingale wager rule.
combing two processing, we could create a function to replicate series
of plays. To test key properties of the interest, profit or loss, we
need applying stop rule for series of plays. Base on the background, we
have three stopping rules:

\begin{verbatim}
   # three stopping rules
    - The player has W dollars, which are 200 dollar starting budgets and 100 dollar winnings
    - The player goes bankrupt
    - The player completes L wagers (or plays)
  
\end{verbatim}

 With the clear operating characteristics, there are four Parameters:

\begin{verbatim}
   # four Parameters
  |***Parameter*** |***Description***                 | ***Starting value***
  |----------------|--------------------------------- | --------------------
  |B               |Starting budge                    | $200
  |W               |Maximum wager                     | $300 (Starting budget + $100 winnings)
  |L               |Maximum number of plays           | 1000 plays
  |M               |Winning threshold for stopping    | $100     
  
\end{verbatim}

\textbf{\emph{Simulation Explanations}}\\
 \textbf{\emph{Simulation Function for Spin of the Wheel}}

 Now, we could start the computer simulation step by step. First, the
computer simulation helps us get a random solution of the single spin of
the wheel, as we apply the following code:

\begin{verbatim}
  # Spin of the wheel
  red <- rbinom(1,1,18/38) 
  
  or 
  
  single_spin <- function(){
  possible_outcomes <- c(rep("red",18), rep("black",18), rep("green",2))
  sample(possible_outcomes, 1)
  }
\end{verbatim}

 The code allow us to receive a random spin result as the red
probability is 18 out of 38.

 \textbf{\emph{Simulation Function for Martingale Wager Rule}}

 The Next task is to consider the stimulation of martingale wager rule.
To complete the whole procedures, we need find the previous outcome. If
the previous outcome negative, we need to know previous wager, max
wager, and current budget as well. Then, we are able to calculate
martingale wager. For martingale wager, if the outcome is ``Red'', the
wager will be one, otherwise it will be the minimum amount between twice
of the previous wage, max wage, and the current budget. Here, we have
two codes solutions:

\begin{verbatim}
  # The Single Martingale Wager
  {
  proposed_wager <- ifelse(state$previous_win, 1, 2*state$previous_wager)
  wager <- min(proposed_wager, state$M, state$B)
  }
  
  or
  
  {
  if(previous_outcome == "red") return(1)
  min(2*previous_wager, max_wager, current_budget)
  }
\end{verbatim}

 Now, with the logical, we are going to put all four inputs into the
martingale wager rule and create the function:

\begin{verbatim}
   # The Single Martingale Wager Function
    state$plays <- state$plays + 1
    state$previous_wager <- wager
    if(red){
        # WIN
      state$B <- state$B + wager
      state$previous_win <- TRUE
    }else{
        # LOSE
      state$B <- state$B - wager
      state$previous_win <- FALSE
    }
    state
    }
    
    or 
  
    martingale_wager <- function(previous_wager, previous_outcome, max_wager, current_budget){
    if(previous_outcome == "red") return(1)
    min(2*previous_wager, max_wager, current_budget)
    }
    
\end{verbatim}

 \textbf{\emph{One Play Simulation Function}}\\

  Before using commuter simulation to implement Martingale Strategy over
a long series of plays, we use the ledger to represent each play of the
game. Different from previous stimulation outcomes,we need apply data
frame at one-play stimulation, since one play will includes game
indexes, start budgets, wagers based on the wheel spin outcome, and the
ending budgets. For each play, we know start budgets will be equal to
previous ending budgets, outcomes will be determined by the spin of the
wheel's simulation, the wager will be derived base on the outcome, and
ending budgets equal the sum of starting budgets and wagers. Here are
two codes responses:

\begin{verbatim}
    #One Play Simulation Function
    
    one_play <- function(state){
    # Wager
    proposed_wager <- ifelse(state$previous_win, 1, 2*state$previous_wager)
    wager <- min(proposed_wager, state$M, state$B)
    # Spin of the wheel
    red <- rbinom(1,1,18/38)
    # Update state
    state$plays <- state$plays + 1
    state$previous_wager <- wager
    if(red){
      # WIN
      state$B <- state$B + wager
      state$previous_win <- TRUE
    }else{
      # LOSE
      state$B <- state$B - wager
      state$previous_win <- FALSE
    }
      state
    }
    
    or
    
    one_play <- function(previous_ledger_entry, max_wager){
      # Create a copy of the input object that will become the output object
    out <- previous_ledger_entry
    out[1, "game_index"] <- previous_ledger_entry[1, "game_index"] + 1
    out[1, "starting_budget"] <- previous_ledger_entry[1, "ending_budget"]
    out[1, "wager"] <- martingale_wager(
      previous_wager = previous_ledger_entry[1, "wager"]
      , previous_outcome = previous_ledger_entry[1, "outcome"]
      , max_wager = max_wager
      , current_budget = out[1, "starting_budget"]
    )
    out[1, "outcome"] <- single_spin()
    out[1, "ending_budget"] <- out[1, "starting_budget"] + 
    ifelse(out[1, "outcome"] == "red", +1, -1)*out[1, "wager"]
    return(out)
    }
\end{verbatim}

 The first code solutions is a stimulation function combination of the
previous three parts. The second code solution demonstrates the whole
idea of ledger, representing the reflection of one play

 \textbf{\emph{Series of Plays}}

 For get the sequence of plays, we need to simulate series of plays.
Generally, it is duplicated plays based one one-play simulation. But,
the initial play has some differences. First, to mimic the round 1
correctly, we needs setup the game 0 as the initial play. Then, we will
apply For loop function, allowing the computer simulate tons of play
round until the play meet stop rules, which we wile talk later. Here we
have two codes solutions.

\begin{verbatim}
    one_series <- function(
    B = 200
    , W = 300
    , L = 1000
    , M = 100
    ){

    # initial state
    state <- list(
      B = B
    , W = W
    , L = L
    , M = M
    , plays = 0
    , previous_wager = 0
    , previous_win = TRUE
    )

    # vector to store budget over series of plays
      budget <- rep(NA, L)

    # For loop of plays
    for(i in 1:L){
      new_state <- state %>% one_play
      budget[i] <- new_state$B
      if(new_state %>% stop_play){
        return(budget[1:i])
      }
      state <- new_state
    }
      budget    
    }

    or
      
    one_series <- function(
      max_games, starting_budget, winning_threshold, max_wager
    ){
    # Initialize ledger
    ledger <- data.frame(
         game_index = 0:max_games
       , starting_budget = NA_integer_
       , wager = NA_integer_
       , outcome = NA_character_
       , ending_budget = NA_integer_
    )
    ledger[1, "wager"] <- 1
    ledger[1, "outcome"] <- "red"
    ledger[1, "ending_budget"] <- starting_budget
    for(i in 2:nrow(ledger)){
      #browser()
      ledger[i,] <- one_play(ledger[i-1,], max_wager)
      if(stopping_rule(ledger[i,], winning_threshold)) break
        }
    # Return non-empty portion of ledger
    ledger[2:i, ]
    }
    
\end{verbatim}

\#\# See the stopping rule below. Explain to your audience how you used
computer simulation to estimate the average number of plays before
stopping. The code below will need to be modified to calculate this
quantity.

 \textbf{\emph{Stop Rules}}

 \textbf{\emph{Earning and Loss}}

 Now, we have all necessary parts. The last thing we need do is let the
whole simulation! here is the function code:

\begin{verbatim}
    #Code 1:
    svg(filename = "loser.svg", width=16, height =9)
    par(cex.axis=2, cex.lab = 2, mar = c(8,8,2,2), bg = rgb(222, 235, 247, max = 255))
    set.seed(1)
    ledger <- one_series(200,200,300,500)
    plot(ledger[,c(1,5)], type = "l", lwd = 5, xlab = "Game Index", ylab = "Budget")
    dev.off()
\end{verbatim}

  with the we code may stimulate the win solution. Here is the graph

\begin{verbatim}
    ![](loser.svg)
\end{verbatim}

svg(filename = ``winner.svg'', width=16, height =9) par(cex.axis=2,
cex.lab = 2, mar = c(8,8,2,2), bg = rgb(222, 235, 247, max = 255))
set.seed(2) l2 \textless- one\_series(200,200,300,500)
plot(l2{[},c(1,5){]}, type = ``l'', lwd = 5, xlab = ``Game Index'', ylab
= ``Budget'') dev.off()

  In the code, as want to the player start the current parameters which
we mention above. The

\hypertarget{you-should-explain-how-you-used-computer-simulation-to-calculate-the-average-earnings-of-a-gambler-that-uses-this-strategy.-as-part-of-the-explanation-provide-a-figure-or-a-series-of-figures-that-show-how-the-gamblers-earnings-or-losses-evolve-over-a-series-of-wagers-at-the-roulette-wheel.-the-x-axis-will-be-the-wager-number-or-play-number-the-y-axis-will-be-earnings.-the-code-below-provides-all-the-functions-youll-need-to-calculate-average-earnings.}{%
\subsection{You should explain how you used computer simulation to
calculate the average earnings of a gambler that uses this strategy. As
part of the explanation, provide a figure (or a series of figures) that
show how the gamblers earnings (or losses) evolve over a series of
wagers at the roulette wheel. (The x-axis will be the wager number (or
play number), the y-axis will be earnings.) The code below provides all
the functions you'll need to calculate average
earnings.}\label{you-should-explain-how-you-used-computer-simulation-to-calculate-the-average-earnings-of-a-gambler-that-uses-this-strategy.-as-part-of-the-explanation-provide-a-figure-or-a-series-of-figures-that-show-how-the-gamblers-earnings-or-losses-evolve-over-a-series-of-wagers-at-the-roulette-wheel.-the-x-axis-will-be-the-wager-number-or-play-number-the-y-axis-will-be-earnings.-the-code-below-provides-all-the-functions-youll-need-to-calculate-average-earnings.}}

 \textbf{\emph{Average earning impact based on a changing parameter}}

\hypertarget{show-your-audience-how-changing-a-parameter-of-the-simulation-see-table-below-does-or-does-not-have-an-impact-on-average-earnings.-a-figure-would-be-helpful.}{%
\subsection{Show your audience how changing a parameter of the
simulation (see table below) does or does not have an impact on average
earnings. A figure would be
helpful.}\label{show-your-audience-how-changing-a-parameter-of-the-simulation-see-table-below-does-or-does-not-have-an-impact-on-average-earnings.-a-figure-would-be-helpful.}}

\hypertarget{be-sure-to-explain-the-limitations-of-the-simulation-identify-simplifications-or-other-sources-of-uncertainty.}{%
\subsection{Be sure to explain the limitations of the simulation;
identify simplifications or other sources of
uncertainty.}\label{be-sure-to-explain-the-limitations-of-the-simulation-identify-simplifications-or-other-sources-of-uncertainty.}}

 \textbf{\emph{limitations of the simulation}}

\end{document}
